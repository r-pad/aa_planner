#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@author: edwardahn

This executable uses the ROS interface to define a node, which calls
an internal generic Python module that is abstracted away from ROS to
run a pre-trained policy on the robot.
"""

import tf

import ackermann_msgs.msg
import nav_msgs.msg
import rospy

from ffast_planner.policy import Policy


class RLPlanner(object):
    """
    Define subscriber/publisher to integrate planner into ROS
    architecture.
    """

    def __init__(self):
        """
        Instantiate ROS and ROS objects.
        """
        self.policy = Policy()
        rospy.init_node('rl_planner')
        self.pub = rospy.Publisher("commands/keyboard",
                ackermann_msgs.msg.AckermannDriveStamped, queue_size=1)
        rospy.Subscriber("ekf_localization/odom", nav_msgs.msg.Odometry,
                self.odometry_callback)


    def odometry_callback(self, odom):
        """
        Callback function for odometry state updates.
        """
        # Get state from localization module
        x = odom.pose.pose.position.x
        y = odom.pose.pose.position.y
        q = odom.pose.pose.orientation
        rpy = tf.transformations.euler_from_quaternion([q.x,q.y,q.z,q.w])
        yaw = rpy[2]
        x_dot = odom.twist.twist.linear.x
        y_dot = odom.twist.twist.linear.y
        yaw_dot = odom.twist.twist.angular.z
        state = [x, y, yaw, x_dot, y_dot, yaw_dot]

        # Publish action from pre-trained model
        action = self.policy.get_action(state)
        msg = ackermann_msgs.msg.AckermannDriveStamped()
        msg.drive.speed = action[0]
        msg.drive.steering_angle = action[1]
        self.pub.publish(msg)


if __name__ == '__main__':
    planner = RLPlanner()
    rospy.spin()
