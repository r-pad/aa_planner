#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@author: edwardahn

This executable uses the ROS interface to define a node, which calls
an internal generic Python module that is abstracted away from ROS to
run a pre-trained policy on the robot.
"""

import ackermann_msgs.msg
import nav_msgs.msg
import rospy


class RLPlanner(object):
    """
    Define subscriber/publisher to integrate planner into ROS
    architecture.
    """

    def __init__(self):
        """
        Instantiate ROS and ROS objects.
        """
        rospy.init_node('rl_planner')
        self.pub = rospy.Publisher("commands/cmd_vel",
                ackermann_msgs.msg.AckermannDriveStamped, queue_size=1)
        rospy.Subscriber("ekf_localization/odom", nav_msgs.msg.Odometry,
                self.odometry_callback)


    def odometry_callback(self, odom):
        """
        Callback function for odometry state updates.
        """
        x = odom.pose.position.x
        y = odom.pose.position.y
        #yaw = tf.getYaw(odom.pose.pose.orientation) # change this
        yaw = odom.pose.pose.orientation
        x_dot = odom.twist.twist.linear.x
        y_dot = odom.twist.twist.linear.y
        yaw_dot = odom.twist.twist.angular.z
        state = [x, y, yaw, x_dot, y_dot, yaw_dot]
        print(state)


if __name__ == '__main__':
    planner = RLPlanner()
    rospy.spin()
